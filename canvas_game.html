<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<style>
  canvas {
    border:1px solid #d3d3d3;
    background-color: #000000;
}
</style>
</head>
<body onload="startGame()">
<script>
  function startGame() {
  myGameArea.start();
}

// Establish game area

var myGameArea = {
  canvas: document.createElement("canvas"),
  start: function () {
    this.canvas.width = 540;
    this.canvas.height = 660;
    this.context = this.canvas.getContext("2d");
    document.body.insertBefore(this.canvas, document.body.childNodes[0]);
    // Set update interval
    this.interval = setInterval(updateGameArea, 20);
    // Keytracking
    window.addEventListener("keydown", function (e) {
      // Gravity triples while spacebar is held
      if(e.keyCode === 32) {
        myEnemy.gravity = 0.15;
        console.log("gravChange!");
      }
      myGameArea.keys = (myGameArea.keys || []);
      myGameArea.keys[e.keyCode] = true;
    })
    window.addEventListener("keyup", function (e) {
      myEnemy.gravity = 0.05
      myGameArea.keys[e.keyCode] = false;
    })
  },
  clear: function () {
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  },
  stop: function() {
    clearInterval(this.interval)
    startGame();
  }
};

// Global game elements

var myGamePiece;

var myEnemy;

var myStar;

var myStars = [];

var grav = 0.05;

function startGame() {
  // Player
  myGamePiece = new component(10, 10, "red", 260, 320, "player");
  // Projectile
  myEnemy = new component(5, 5, "blue", 300, 72, "enemy");
  // Populate starfield before game start (not working properly, may have to re-scope function to run independently of startGame)
  for(i=0; i < myGameArea.canvas.height; i++){
    if(Math.floor(Math.random() * 5) === 4) {
      myStar = new star(Math.floor(Math.random() * 540), i, Math.floor(Math.random() * 4));
        if(myStar.speed === 0){
          myStar.speed = 1;
        }
      myStars.push(myStar);
    }
  }
  // Projectile spawn (Should move these values up as arguments for myEnemy)
  myEnemy.x = Math.floor(Math.random() * 535);
  myEnemy.y = Math.floor(Math.random() * 655);
  myGameArea.start();
  // myEnemy.speedX = randoDirect();
  // myEnemy.speedY = randoDirect();
}

// Deprecated randomly generated 2d movement

function randoDirect() {
  x = Math.random() * 2;
  if(x < 0.55){
    x = 0.55
  }
  if(x > 1.65){
    x = 1.65
  }
  console.log("x: " + x)
  y = Math.floor(Math.random() * 2)
  console.log("y: " + y);
  if(y === 1) {
    x = -Math.abs(x)
  }
  return x;
}

// Star constructor

function star(x, y, speed) {
  this.x = x;
  this.y = y;
  this.color = "white";
  this.speed = speed;
  this.update = function() {
    ctx = myGameArea.context;
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y, 1, 1) 
  }
  this.newPos = function() {
  this.y += this.speed
  }
}

// Player and projectile constructor

function component(width, height, color, x, y, type) {
  this.width = width;
  this.height = height;
  this.speedX = 0;
  this.speedY = 0;
  this.x = x;
  this.y = y;
  this.type = type
  if(this.type === "enemy") {
    this.gravity = grav;
    this.gravitySpeedX = 0;
    this.gravitySpeedY = 0;
  }
  this.update = function () {
    ctx = myGameArea.context;
    if(this.type === "enemy") {
      ctx.fillStyle = "rgb(" + Math.floor(Math.random() * 255) + "," + Math.floor(Math.random() * 255) + "," + Math.floor(Math.random() * 255) + ")";
    }
    else{
    ctx.fillStyle = color;
    }
    ctx.fillRect(this.x, this.y, this.width, this.height);
  };
  this.newPos = function () {
    this.x += this.speedX;
    this.y += this.speedY;
    if (this.type === "player") {
    if(this.x > 530) {
      this.x = 530
    }
    if(this.x < 0){
      this.x = 0
    }
    if(this.y > 650) {
      this.y = 650
    }
    if(this.y < 0) {
      this.y = 0
    }}
    if (this.type === "enemy"){
    if(this.x > 535) {
      this.x = 535
    }
    if(this.x < 0) {
      this.x = 0
    }
    if(this.y > 655) {
      this.y = 655
    }
    if(this.y < 0) {
      this.y = 0
    }
    
    // Alters gravityspeed based on location relative to player

    if(this.x < myGamePiece.x && this.y < myGamePiece.y){
    this.gravitySpeedX += this.gravity;
    this.gravitySpeedY += this.gravity;
    this.x += this.speedX + this.gravitySpeedX;
    this.y += this.speedY + this.gravitySpeedY;
    }
    if(this.x > myGamePiece.x && this.y > myGamePiece.y){
    this.gravitySpeedX -= this.gravity;
    this.gravitySpeedY -= this.gravity;
    this.x += this.speedX + this.gravitySpeedX;
    this.y += this.speedY + this.gravitySpeedY;
    }
    if(this.x < myGamePiece.x && this.y > myGamePiece.y){
    this.gravitySpeedX += this.gravity;
    this.gravitySpeedY -= this.gravity;
    this.x += this.speedX + this.gravitySpeedX;
    this.y += this.speedY + this.gravitySpeedY;
    }
    if(this.x > myGamePiece.x && this.y < myGamePiece.y){
    this.gravitySpeedX -= this.gravity;
    this.gravitySpeedY += this.gravity;
    this.x += this.speedX + this.gravitySpeedX;
    this.y += this.speedY + this.gravitySpeedY;
    }
    if(this.x === myGamePiece.x && this.y < myGamePiece.y){
      this.gravitySpeedY += this.gravity;
      this.y += this.speedY + this.gravitySpeedY;
    }
    if(this.x === myGamePiece.x && this.y > myGamePiece.y){
      this.gravitySpeedY -= this.gravityspeedY;
      this.y += this.speedY + this.gravitySpeedY;
    }
    if(this.x < myGamePiece.x && this.y === myGamePiece.y){
      this.gravitySpeedX += this.gravity;
      this.x += this.speedX + this.gravitySpeedX;
    }
    if(this.x > myGamePiece.x && this.y === myGamePiece.y){
      this.gravitySpeedX -= this.gravity;
      this.x += this.speedX + this.gravitySpeedX;
    }
    this.hitEdge();
  }
},

  // function to stop projectiles moving beyond game boundaries. Only accounts for the bottom and the right side though.

  this.hitEdge = function() {
    var rockBottom = myGameArea.canvas.height - this.height;
    var rockRight = myGameArea.canvas.width - this.width;
      if (this.y > rockBottom) {
        this.y = rockBottom;
        console.log("Triggered rockBottom");
      }
      if(this.x > rockRight) {
        this.x = rockRight;
        console.log("Triggered rockRight");
      }
  }

  // Collision detection.

  this.crashWith = function(otherObj) {
    var myLeft = this.x;
    var myRight = this.x + (this.width);
    var myTop = this.y;
    var myBottom = this.y + (this.height);
    var otherLeft = otherObj.x
    var otherRight = otherObj.x + (otherObj.width);
    var otherTop = otherObj.y;
    var otherBot = otherObj.y + (otherObj.height);
    var crash = true;
    if((myBottom < otherTop) || (myTop > otherBot) || (myLeft > otherRight) || (myRight < otherLeft)) {
      crash = false;
    }
    return crash;
  }
}

// Redraws the gameArea.

function updateGameArea() {
  if (myGamePiece.crashWith(myEnemy)) {
    myGameArea.stop();
  }
  else {
  myGameArea.clear();
  if(Math.floor(Math.random() * 5) === 4) {
    myStar = new star(Math.floor(Math.random() * 540), 0, Math.floor(Math.random() * 4))
    if(myStar.speed === 0) {
      myStar.speed = 1;
    };
    myStars.push(myStar);
  }
  for(i=0; i < myStars.length; i++){
  myStars[i].update();
  myStars[i].newPos();
  if(myStars[i].y > myGameArea.canvas.height){
    myStars.splice(i, 1)
  }
  }
  myEnemy.update();
  myEnemy.newPos();
  myGamePiece.speedX = 0;
  myGamePiece.speedY = 0;
  if (myGameArea.keys && myGameArea.keys[37]) {
    myGamePiece.speedX = -1
  }
  if (myGameArea.keys && myGameArea.keys[39]) {
    myGamePiece.speedX = 1;
  }
  if (myGameArea.keys && myGameArea.keys[38]) {
    myGamePiece.speedY = -1; 
  }
  if (myGameArea.keys && myGameArea.keys[40]) {
    myGamePiece.speedY = 1; 
  }
  myGamePiece.update();
  myGamePiece.newPos();
}}

// Original function I wrote for movement. Not exactly obsolete because it tackles movement in a different fashion, but for the time-being it's being put to sleep. Could be useful for a space game or something.

// document.onkeyup = function(event) {
//   var uInput = event.key;
//   console.log(uInput);
//   switch (uInput) {
//     case "ArrowLeft":
//       myGamePiece.speedX -= 1;
//       console.log("left case")
//       break;
//     case "ArrowRight":
//       myGamePiece.speedX += 1;
//       console.log("right case")
//       break;
//     case "ArrowUp":
//       myGamePiece.speedY -= 1;
//       console.log("up case")
//       break;
//     case "ArrowDown":
//       myGamePiece.speedY += 1;
//       console.log("down case")
//       break;
//     case "]":
//       console.log("Xpos: " + myGamePiece.x + " Ypos: " + myGamePiece.y);
//     default:
//       console.log("break case")
//       break;
//   }
// }

</script>
</body>
</html>